<!DOCTYPE html>
    <head>
        <meta charset = "UTF-8">
        <meta name = "Description" content = "Cristian D. Conte - Computer Engineer">
        <meta name = "viewport" content = "width=device-width, initial-scale=1.0">
        <base href="./" target="_blank">
        <title>Cristian D. Conte</title>
        
		<!-- Preload resources -->
		<link rel = "preload" href = "./index.css" as = "style"/>

		<!-- Load the stylesheets -->
		<link rel = "stylesheet" type = "text/css" href = "./index.css"/>
    </head>

    <body>
        <div id = "page1"></div> <!-- Name and Title -->
        <div id = "page2"></div> <!-- Professional Experience -->
        <div id = "page3"></div> <!-- Personal Projects -->
        <div id = "page4"></div> <!-- Languages and Frameworks -->
        <div id = "page5"></div> <!-- Contact me -->
    </body>
</html>

<script type = "module">
    import {
        IterableArray,
    } from "./dsa/iterable_array.js";
    
    import {
        IterableSet,
    } from "./dsa/iterable_set.js";

    import {
        DoublyLinkedList,
    } from "./dsa/doubly_linked_list.js";

    import {
        Graph,
    } from "./dsa/graph.js";

    import {
        UInt8Matrix,
    } from "./dsa/matrix/UInt8Matrix.js";

    import {
        linear 
    } from "./algorithms/linear.js";
    
    import {
        DFSStrategy
    } from "./algorithms/graph_exploration/dfs.js";

    import {
        BFSStrategy
    } from "./algorithms/graph_exploration/bfs.js";

    import {
        SpringEmbedderEadesStrategy
    } from "./algorithms/graph_visualization/spring_embedder_eades.js";
    
    import {
        SpringEmbedderFruchtermanStrategy
    } from "./algorithms/graph_visualization/spring_embedder_fruchterman.js";

    import {
        ForceDirectedGravityStrategy
    } from "./algorithms/graph_visualization/force_directed_gravity.js";

    import {
        swap,
        shuffle, 
        quicksort,
        LESSER_FLAG,
        HIGHER_FLAG,
        EQUAL_FLAG,
    } from "./algorithms/sorting.js";

    window.addEventListener("load", () => {
        {
            //Create page 1 elements
            const page1_name_arr = "Cristian D. Conte".split("");
            const page1_title_arr = "Computer Engineer".split("");
            let page1_els_arr = page1_name_arr.concat(page1_title_arr);

            let create_el_fun = (el_str, idx) => {
                let p_el = document.createElement("p");

                p_el.className = "page1_name_char_p";

                p_el.setAttribute("data-idx", idx);
                p_el.setAttribute("data-delta-x", 0);
                p_el.setAttribute("data-delta-y", 0);
                p_el.setAttribute("data-init-pos-x", "-");
                p_el.setAttribute("data-init-pox-y", "-");

                p_el.innerText = el_str;

                return p_el;
            }; // TODO: Create factories for turning data into visual elements

            let page1_els = linear(page1_els_arr, create_el_fun);
            
            //Create page 1 effects
            const custom_swap_shuffling = (arr, i, j) => {
                swap(arr, i, j);
            };

            let milliseconds = 0;
            let increase = 100;
            const custom_swap_sorting = (arr, i, j) => {
                if(i == j) return;
                
                const arr_i = arr[i];
                const arr_j = arr[j];

                let arr_i_pos, arr_j_pos;

                if(arr_i.getAttribute("data-init-pos-x") == "-") {
                    arr_i_pos = arr_i.getBoundingClientRect();
                    arr_i.setAttribute("data-init-pos-x", arr_i_pos.x);
                    arr_i.setAttribute("data-init-pos-y", arr_i_pos.y);
                } else {
                    arr_i_pos = {
                        x: Number.parseInt(arr_i.getAttribute("data-init-pos-x")),
                        y: Number.parseInt(arr_i.getAttribute("data-init-pos-y")),
                    }
                }

                if(arr_j.getAttribute("data-init-pos-x") == "-") {
                    arr_j_pos = arr_j.getBoundingClientRect();
                    arr_j.setAttribute("data-init-pos-x", arr_j_pos.x);
                    arr_j.setAttribute("data-init-pos-y", arr_j_pos.y);
                } else {
                    arr_j_pos = {
                        x: Number.parseInt(arr_j.getAttribute("data-init-pos-x")),
                        y: Number.parseInt(arr_j.getAttribute("data-init-pos-y")),
                    }
                }

                const arr_i_old_delta_x = Number.parseInt(arr_i.getAttribute("data-delta-x"));
                const arr_i_old_delta_y = Number.parseInt(arr_i.getAttribute("data-delta-y"));
                const arr_j_old_delta_x = Number.parseInt(arr_j.getAttribute("data-delta-x"));
                const arr_j_old_delta_y = Number.parseInt(arr_j.getAttribute("data-delta-y"));
                
                const delta_x = Math.round(arr_i_pos.x + arr_i_old_delta_x - arr_j_pos.x - arr_j_old_delta_x);
                const delta_y = Math.round(arr_i_pos.y + arr_i_old_delta_y - arr_j_pos.y - arr_j_old_delta_y);

                const arr_i_transform = `translate3d(${arr_i_old_delta_x - delta_x}px, ${arr_i_old_delta_y - delta_y}px, 0px)`;
                const arr_j_transform = `translate3d(${arr_j_old_delta_x + delta_x}px, ${arr_j_old_delta_y + delta_y}px, 0px)`;
                
                arr_i.setAttribute("data-delta-x", arr_i_old_delta_x - delta_x);
                arr_i.setAttribute("data-delta-y", arr_i_old_delta_y - delta_y);
                arr_j.setAttribute("data-delta-x", arr_j_old_delta_x + delta_x);
                arr_j.setAttribute("data-delta-y", arr_j_old_delta_y + delta_y);

                swap(arr, i, j);

                milliseconds += increase; //TODO: add a proper easing
                //increase -= 1;

                setTimeout(() => {
                    arr_i.style.transform = arr_i_transform;
                    arr_j.style.transform = arr_j_transform;
                }, milliseconds);
            };

            shuffle(page1_els, custom_swap_shuffling);
            
            linear(page1_els, (el) => document.getElementById("page1").appendChild(el));
            
            quicksort(
                page1_els,
                (el1, el2) => {
                    const el1_idx = Number.parseInt(el1.getAttribute("data-idx"));
                    const el2_idx = Number.parseInt(el2.getAttribute("data-idx"));

                    return el1_idx < el2_idx ? LESSER_FLAG : HIGHER_FLAG;
                },
                custom_swap_sorting,
                0, 
                page1_els.length - 1
            );
        }
        
        {
            // Create page 2 elements
            const experiences_arr = [
                {
                    value: ["Professional Experience"] // FIRST NODE
                }, 
                {
                    value: ["2016", "I.T. Technician", "S.i.c.o.t. S.R.L."] 
                }, 
                {
                    value: ["2017", "I.T. Technician", "Lugo Town Hall"] 
                }, 
                {
                    value: ["2022", "Web Developer", "Il BuonLatte"] 
                }, 
                {
                    value: ["2023", "AI / ML Engineer Intern", "SpecialVideo S.R.L."] 
                },
                {
                    value: ["Null"] // LAST NODE
                }
            ];

            let head = null;
            let curr_node = null;
            const create_linked_list = (el) => {
                const new_node = new DoublyLinkedList(el.value);

                if(!head) {
                    head = new_node;
                    curr_node = head;
                    return;
                }

                const tmp = curr_node;
                curr_node._next = new_node;
                curr_node = new_node;
                curr_node._prev = tmp;
            }; // TODO: turn this into a proper factory
            
            const create_visual_node = (node) => {
                let container_el = document.createElement("div");
                let div_el = document.createElement("div");

                container_el.className = "experiences_node_container";
                div_el.className = "experiences_node";

                for(const val of node.value()) {
                    let p_el = document.createElement("p");

                    p_el.className = "experiences_node_internal_p";
                    p_el.innerText = val;

                    div_el.appendChild(p_el);
                }
                
                //If there's a previous node, append a visual node 
                //that allows to go to the previous node if interacted with
                if(node.prev()) {
                    let arr_el = document.createElement("div");
                    
                    arr_el.innerHTML = "&larr;";
                    arr_el.className = "experiences_node_prev_arr";

                    arr_el.addEventListener("click", (event) => {
                        arr_el.parentElement.previousElementSibling.scrollIntoView({ behavior: "smooth", inline: "center" });
                    }); //TODO: use USS && add arrows appearing and disappearing effects

                    container_el.appendChild(arr_el);
                }

                container_el.appendChild(div_el);

                //If there's a next 
                if(node.next()) {
                    let arr_el = document.createElement("div");

                    arr_el.innerHTML = "&rarr;";
                    arr_el.className = "experiences_node_next_arr";
                    
                    arr_el.addEventListener("click", (event) => {
                        arr_el.parentElement.nextElementSibling.scrollIntoView({ behavior: "smooth", inline: "center" });
                    }); //TODO: use USS && add arrows appearing and disappearing effects

                    container_el.appendChild(arr_el);
                }

                return container_el;
            }; // TODO: turn this into a proper factory

            let test_arr = new IterableArray(experiences_arr);  
            test_arr.forEach(create_linked_list);
            
            head.forEach((el, idx) => document.getElementById("page2").appendChild(create_visual_node(el)));

        }

        {
            // Create page 3 elements
            const projects_arr = [
                {
                    value: ["Personal Projects", null] // FIRST NODE
                }, 
                {
                    value: ["2020", "My old website", "https://cristiandavideconte.github.io/myPersonalWebPage/"],
                }, 
                {
                    value: ["2021", "Covid Protection Checker", "https://github.com/CristianDavideConte/SistemiDigitali"],
                }, 
                {
                    value: ["2022", "Universal Smooth Scroll", "https://github.com/CristianDavideConte/universalSmoothScroll"],
                }, 
                {
                    value: ["Null", null] // LAST NODE
                }
            ];

            let head = null;
            let curr_node = null;
            const create_linked_list = (el) => {
                const new_node = new DoublyLinkedList(el.value);

                if(!head) {
                    head = new_node;
                    curr_node = head;
                    return;
                }

                const tmp = curr_node;
                curr_node._next = new_node;
                curr_node = new_node;
                curr_node._prev = tmp;
            }; // TODO: turn this into a proper factory
            
            const create_visual_node = (node) => {
                let container_el = document.createElement("div");
                let div_el = document.createElement("div");
                let i;

                container_el.className = "projects_node_container";
                div_el.className = "projects_node";

                for(i = 0; i < node.value().length - 1; i++) {
                    const val = node.value()[i];
                    let p_el = document.createElement("p");

                    p_el.className = "projects_node_internal_p";
                    p_el.innerText = val;

                    div_el.appendChild(p_el);
                }
                
                if(node.value()[i] != null) {
                    //Visit link
                    let link_el = document.createElement("a");

                    link_el.className = "projects_node_internal_a";
                    link_el.innerText = "GOTO";
                    link_el.href = node.value()[i];
                    link_el.target = "_blank";

                    div_el.appendChild(link_el);
                }
                
                //If there's a previous node, append a visual node 
                //that allows to go to the previous node if interacted with
                if(node.prev()) {
                    let arr_el = document.createElement("div");
                    
                    arr_el.innerHTML = "&larr;";
                    arr_el.className = "projects_node_prev_arr";

                    arr_el.addEventListener("click", (event) => {
                        arr_el.parentElement.previousElementSibling.scrollIntoView({ behavior: "smooth", inline: "center" });
                    }); //TODO: use USS && add arrows appearing and disappearing effects

                    container_el.appendChild(arr_el);
                }

                container_el.appendChild(div_el);

                //If there's a next 
                if(node.next()) {
                    let arr_el = document.createElement("div");

                    arr_el.innerHTML = "&rarr;";
                    arr_el.className = "projects_node_next_arr";
                    
                    arr_el.addEventListener("click", (event) => {
                        arr_el.parentElement.nextElementSibling.scrollIntoView({ behavior: "smooth", inline: "center" });
                    }); //TODO: use USS && add arrows appearing and disappearing effects

                    container_el.appendChild(arr_el);
                }

                return container_el;
            }; // TODO: turn this into a proper factory

            let test_arr = new IterableArray(projects_arr);  
            test_arr.forEach(create_linked_list);
            
            head.forEach((el, idx) => document.getElementById("page3").appendChild(create_visual_node(el)));
        }


        {   
            //Page 4 elements
            const adj_list = [
                ["Git", "C"],                
                ["Git", "C++"],                
                ["C", "C++"],                
                ["C", "Rust"],                
                ["C", "Java"],                
                ["C++", "Rust"],                
                ["C++", "OpenGL"],                
                ["Rust", "OpenGL"],  //TODO: remove              
                ["Rust", "Java"],                 
                ["Java", "SQL"],                
                ["Java", "Android"],                
                ["Java", "Javascript"],                
                ["Javascript", "React"],                
                ["Javascript", "CSS"],                
                ["Javascript", "HTML"],                
                ["Javascript", "Dart"],                
                ["Javascript", "Python"],                
                ["Dart", "Flutter"],                
                ["Python", "Numpy"],                
                ["Python", "Tensorflow"],                
                ["Python", "Pytorch"],                
                ["Tensorflow", "Pytorch"],                
                //["Tensorflow", "ViT"],                
                //["Pytorch", "ViT"],                
            ];
            
            const node_radius = 50;
            const node_diameter = 2 * node_radius; // px
            const padding = 50;
            const min_x = padding;
            const min_y = padding;
            const max_x = window.innerWidth - padding;
            const max_y = window.innerHeight - padding;

            //const strategy = new DFSStrategy();
            const strategy = new BFSStrategy();  
            
            const isDirectedGraph = false;
            const graph = new Graph(adj_list, isDirectedGraph, strategy); 

            const visualization_strategy = new SpringEmbedderEadesStrategy(min_x, min_y, max_x, max_y, node_diameter);
            //const visualization_strategy = new SpringEmbedderFruchtermanStrategy(min_x, min_y, max_x, max_y, node_diameter);
            //const visualization_strategy = new ForceDirectedGravityStrategy(min_x, min_y, max_x, max_y, node_diameter);

            let nodes_pos = visualization_strategy.getInitialNodePositions(graph);

            const nodes = new IterableSet(graph.nodes());
            const nodes_mapping = new Map();
            let enable_drag = false;

            const create_visual_edge = (edge) => {
                const div_el = document.createElement("div");
                const from_pos = nodes_pos.get(edge[0]);
                const to_pos = nodes_pos.get(edge[1]);

                const l = Math.sqrt(Math.pow(from_pos[0] - to_pos[0], 2) + Math.pow(from_pos[1] - to_pos[1], 2));
                const d = Math.sqrt(Math.pow(from_pos[0] - to_pos[0], 2) + Math.pow(from_pos[1] - to_pos[1] + l, 2));
                
                const to_degrees = (a) => a * 180 / Math.PI;
                const to_0_360_range = (a) => a < 0 ? a + 360 : a;
                const sign = from_pos[0] > to_pos[0] ? 1 : -1;
                let angle = sign * Math.acos(1 - Math.pow(d, 2) / (2 * Math.pow(l, 2)));
                angle = to_0_360_range(to_degrees(angle));
                
                div_el.className = "programming_language_edge";
                div_el.setAttribute("data-from", edge[0]);
                div_el.setAttribute("data-to", edge[1]);
                div_el.setAttribute("data-angle", angle);
                div_el.style.transform = `translate3d(${from_pos[0] + node_radius}px, ${from_pos[1] + node_radius}px, 0px) rotate(${angle}deg) scaleY(${Math.trunc(l)})`;
                div_el.style.transition = "0s";

                return div_el;
            };

            const create_visual_node = (node) => {
                const div_el = document.createElement("div");
                const img_el = document.createElement("img");
                const node_pos = nodes_pos.get(node);
                let track_drag = false;
                
                div_el.className = "programming_languages_node";
                div_el.style.transform = `translate3d(${node_pos[0]}px, ${node_pos[1]}px, 0px)`;
                img_el.src = `imgs/page_4/${node}.png`;

                div_el.addEventListener("mousedown", () => {
                    if(!enable_drag) return;
                    track_drag = true;
                    div_el.classList.add("dragged");
                }, {passive: true});

                window.addEventListener("mousemove", (event) => {
                    if(!track_drag) return;
                    
                    const node_pos = nodes_pos.get(node);
                    node_pos[0] += event.movementX;
                    node_pos[1] += event.movementY;

                    move_nodes(false);
                }, {passive: true});

                window.addEventListener("mouseup", () => {
                    if(!enable_drag || !track_drag) return;

                    track_drag = false;
                    div_el.classList.remove("dragged");
                    move_nodes(true);
                }, {passive: true});

                div_el.appendChild(img_el);
                nodes_mapping.set(node, div_el);

                return div_el;
            };

            const move_nodes = (run_physics = true) => {
                if(run_physics) {
                    nodes_pos = visualization_strategy.updatePlacement(graph, nodes_pos);
                }
                        
                nodes.forEach((el, idx) => {
                    const node_pos = nodes_pos.get(el);
                    nodes_mapping.get(el).style.transform = `translate3d(${node_pos[0]}px, ${node_pos[1]}px, 0px)`;
                    nodes_mapping.get(el).style.transition = run_physics ? "" : "0s";
                });

                edges.forEach((el, idx) => {
                    const from_pos = nodes_pos.get(el.getAttribute("data-from"));
                    const to_pos = nodes_pos.get(el.getAttribute("data-to"));
                    const old_angle = Number.parseFloat(el.getAttribute("data-angle"));

                    const l = Math.sqrt(Math.pow(from_pos[0] - to_pos[0], 2) + Math.pow(from_pos[1] - to_pos[1], 2));
                    const d = Math.sqrt(Math.pow(from_pos[0] - to_pos[0], 2) + Math.pow(from_pos[1] - to_pos[1] + l, 2));
                    
                    //TODO: put this statements into a function and use it for the angle initialization too
                    const to_degrees = (a) => a * 180 / Math.PI;
                    const to_0_360_range = (a) => a < 0 ? a + 360 : a;
                    const sign = from_pos[0] > to_pos[0] ? 1 : -1;
                    let angle = sign * Math.acos(1 - Math.pow(d, 2) / (2 * Math.pow(l, 2)));
                    angle = to_0_360_range(to_degrees(angle));
                    
                    if(Math.abs(old_angle - angle) > 180) {
                        const angle_1 = angle - (old_angle % 360);
                        const angle_2 = 360 - Math.abs(angle_1);

                        if(Math.abs(angle_1) < angle_2) {
                            angle = old_angle + angle_1;
                        } else {
                            angle = old_angle - Math.sign(angle_1) * angle_2;
                        }
                    }

                    el.setAttribute("data-angle", angle);
                    el.style.transform = `translate3d(${from_pos[0] + node_radius}px, ${from_pos[1] + node_radius}px, 0px) rotate(${angle}deg) scaleY(${Math.trunc(l)})`;
                    el.style.transition = run_physics ? "" : "0s";
                });
            }

            const edges = [];
            adj_list.forEach((el, idx) => {
                edges[idx] = create_visual_edge(el);
                document.getElementById("page4").appendChild(edges[idx]);
            });

            nodes.forEach((el, idx) => document.getElementById("page4").appendChild(create_visual_node(el)));

            let num_iter = 0;
            let max_num_iter = 100;
            let milliseconds = 0.5;

            setTimeout(function update_nodes_and_edges() {
                if(num_iter == max_num_iter) {
                    enable_drag = true;
                    return;
                }

                move_nodes();
                num_iter++;

                document.getElementById("page4").className = Number.parseInt(
                    document.getElementById("page4").className || "0"
                ) + 1; // TODO: debug, remove

                setTimeout(update_nodes_and_edges, milliseconds * num_iter);
            }, 0);
        }
    });

    
    {   
        //Page 5 elements
        const grid_rows = 10; //cells
        const grid_cols = 5; //cells
        const contacts_padding_space = 2; //cells

        let obstacles = [];
        const grid = new UInt8Matrix(grid_rows, grid_cols);

        grid.set(9, 4, 1);

        console.log(grid.to_string());
    }
</script>
